\section{Aggiunte Matte}

\subsection{FFT double}
\begin{itemize}
    \item Può avere problemi di approssimazione con numeri grandi, ricordarsi di arrotondare bene
    \item Non mi va con cose negative
    \item (Non me ne prendo responsabilità)
\end{itemize}
\begin{lstlisting}
  #include <bits/stdc++.h>

  using namespace std;

  #define _USE_MATH_DEFINES
  #include <complex>
  #include <vector>
  #include <cmath>

  std::vector<std::complex<double> > fast_fourier_transform(std::vector<std::complex<double> > x, bool inverse = false) {

      std::vector<std::complex<double> > w(x.size(), 0.0);
      w[0] = 1.0;
      for(int pow_2 = 1; pow_2 < (int)x.size(); pow_2 *= 2) {
          w[pow_2] = std::polar(1.0, 2*M_PI * pow_2/x.size() * (inverse ? 1 : -1) );
      }
      for(int i=3, last=2; i < (int)x.size(); i++) {
          if(w[i] == 0.0) {
              w[i] = w[last] * w[i-last];
          } else {
              last = i;
          }
      }

      for(int block_size = x.size(); block_size > 1; block_size /= 2) {
          std::vector<std::complex<double> > new_x(x.size());

          for(int start = 0; start < (int)x.size(); start += block_size) {
              for(int i=0; i<block_size; i++) {
                  new_x[start + block_size/2 * (i%2) + i/2] = x[start + i];
              }
          }
          x = new_x;
      }

      for(int block_size = 2; block_size <= (int)x.size(); block_size *= 2) {
          std::vector<std::complex<double> > new_x(x.size());
          int w_base_i = x.size() / block_size;

          for(int start = 0; start < (int)x.size(); start += block_size) {
              for(int i=0; i < block_size/2; i++) {
                  new_x[start+i]              = x[start+i] + w[w_base_i*i] * x[start + block_size/2 + i];
                  new_x[start+block_size/2+i] = x[start+i] - w[w_base_i*i] * x[start + block_size/2 + i];
              }
          }
          x = new_x;
      }
      return x;
  }
  
  struct Polynomial {
      std::vector<double> a;
      Polynomial(std::vector<double> new_a) : a(new_a) {}

      Polynomial operator*(Polynomial r) {
          int power_2 = 1;
          while(power_2 < (int)(a.size() + r.a.size() - 1)) {
              power_2 *= 2;
          }

          std::vector<std::complex<double> > x_l(power_2, 0.0);
          std::vector<std::complex<double> > x_r(power_2, 0.0);
          std::vector<std::complex<double> > product(power_2, 0.0);

          for(int i=0; i<(int)a.size(); i++) {
              x_l[i] = a[i];
          }
          for(int i=0; i<(int)r.a.size(); i++) {
              x_r[i] = r.a[i];
          }
          x_l = fast_fourier_transform(x_l);
          x_r = fast_fourier_transform(x_r);
          for(int i=0; i<power_2; i++) {
            product[i] = x_l[i] * x_r[i];
          }
          product = fast_fourier_transform(product, true);

          std::vector<double> result_a(a.size() + r.a.size() - 1);
          for(int i=0; i<(int)result_a.size(); i++) {
              result_a[i] = product[i].real() / power_2;
          }
          return result_a;
      }
  };

  int main() {
    vector<double> t(100000);
    for(int i=0; i<100000; i++) t[i]=i;
      Polynomial x_1(t);
      Polynomial x_2({2, 0, 1});
      Polynomial result = x_1 * x_2;

      ofstream out("output.txt");
      for(int i=0; i<result.a[i]; i++){
        out << (long long)(result.a[i] + 0.5 - (result.a[i]<0)) << " ";
      }
      return 0;
  }
\end{lstlisting}

\subsection{FFT modulo M}
\begin{itemize}
    \item Accetta numeri negativi, bisogna stare attenti ai moduli
    \item (Non me ne prendo responsabilità)
\end{itemize}
\begin{lstlisting}
 #include <bits/stdc++.h>
  using namespace std;

  #define N	100001
  #define L	18	/* L = ceil(log2(N * 2 - 1)) */
  #define N_	(1 << L)
  #define MD	469762049	/* MD = 56 * 2^23 + 1 */

  int *wu[L + 1], *wv[L + 1];

  int power(int a, int k) {
    long long b = a, p = 1;

    while (k) {
      if (k & 1)
        p = p * b % MD;
      b = b * b % MD;
      k >>= 1;
    }
    return p;
  }
  void init() {
    int l, i, u, v;
    u = power(3, (MD - 1) >> L);
    v = power(u, MD - 2);

    for (l = L; l > 0; l--) {
      int n = 1 << (l - 1);

      wu[l] = (int *) malloc(n * sizeof *wu[l]);
      wv[l] = (int *) malloc(n * sizeof *wv[l]);

      wu[l][0] = wv[l][0] = 1;
      for (i = 1; i < n; i++) {
        wu[l][i] = (long long) wu[l][i - 1] * u % MD;
        wv[l][i] = (long long) wv[l][i - 1] * v % MD;
      }

      u = (long long) u * u % MD, v = (long long) v * v % MD;
    }
  }
  void ntt_(int *aa, int l, int inverse) {
    if (l > 0) {
      int n = 1 << l;
      int m = n >> 1;
      int *ww = inverse ? wv[l] : wu[l];
      int i, j;
      ntt_(aa, l - 1, inverse);
      ntt_(aa + m, l - 1, inverse);
      for (i = 0; (j = i + m) < n; i++) {
        int a = aa[i];
        int b = (long long) aa[j] * ww[i] % MD;
        if ((aa[i] = a + b) >= MD)
          aa[i] -= MD;
        if ((aa[j] = a - b) < 0)
          aa[j] += MD;
      }
    }
  }
  void ntt(int *aa, int l, int inverse) {
    int n_ = 1 << l, i, j;
    for (i = 0, j = 1; j < n_; j++) {
      int b;
      int tmp;
      for (b = n_ >> 1; (i ^= b) < b; b >>= 1)
        ;
      if (i < j)
        tmp = aa[i], aa[i] = aa[j], aa[j] = tmp;
    }
    ntt_(aa, l, inverse);
  }
  void mult(int *aa, int n, int *bb, int m, int *out) {
    static int aa_[N_], bb_[N_];
    int l, n_, i, v;
    l = 0;
    while (1 << l <= n - 1 + m - 1)
      l++;
    n_ = 1 << l;
    memcpy(aa_, aa, n * sizeof *aa), memset(aa_ + n, 0, (n_ - n) * sizeof *aa_);
    memcpy(bb_, bb, m * sizeof *bb), memset(bb_ + m, 0, (n_ - m) * sizeof *bb_);
    ntt(aa_, l, 0), ntt(bb_, l,  0);
    for (i = 0; i < n_; i++)
      out[i] = (long long) aa_[i] * bb_[i] % MD;
    ntt(out, l, 1);
    v = power(n_, MD - 2);
    for (i = 0; i < n_; i++)
      out[i] = (long long) out[i] * v % MD;
  }
  int main() {
    static int aa[N], bb[N], out[N_];
    int n, m, i;
    init();
    scanf("%d%d", &n, &m), n++, m++;
    for (i = 0; i < n; i++)
      scanf("%d", &aa[i]);
    for (i = 0; i < m; i++)
      scanf("%d", &bb[i]);
    mult(aa, n, bb, m, out);
    for (i = 0; i < n + m - 1; i++)
      printf("%d ", out[i]);
      printf("\n");
    return 0;
  }
\end{lstlisting}

\subsection{Euclide esteso, ma iterativo}
\begin{lstlisting}
int gcd(int a, int b, int& x, int& y) {
    x = 1, y = 0;
    int x1 = 0, y1 = 1, a1 = a, b1 = b;
    while (b1) {
        int q = a1 / b1;
        tie(x, x1) = make_tuple(x1, x - q * x1);
        tie(y, y1) = make_tuple(y1, y - q * y1);
        tie(a1, b1) = make_tuple(b1, a1 - q * b1);
    }
    return a1;
}
\end{lstlisting}

\subsection{Convex Hull}
\begin{lstlisting}
  struct pt {
      double x, y;
  };

  int orientation(pt a, pt b, pt c) {
      double v = a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);
      if (v < 0) return -1; // clockwise
      if (v > 0) return +1; // counter-clockwise
      return 0;
  }
  bool cw(pt a, pt b, pt c, bool include_collinear) {
      int o = orientation(a, b, c);
      return o < 0 || (include_collinear && o == 0);
  }
  bool collinear(pt a, pt b, pt c) { return orientation(a, b, c) == 0; }
  void convex_hull(vector<pt>& a, bool include_collinear = false) {
      pt p0 = *min_element(a.begin(), a.end(), [](pt a, pt b) {
          return make_pair(a.y, a.x) < make_pair(b.y, b.x);
      });
      sort(a.begin(), a.end(), [&p0](const pt& a, const pt& b) {
          int o = orientation(p0, a, b);
          if (o == 0)
              return (p0.x-a.x)*(p0.x-a.x) + (p0.y-a.y)*(p0.y-a.y)
                  < (p0.x-b.x)*(p0.x-b.x) + (p0.y-b.y)*(p0.y-b.y);
          return o < 0;
      });
      if (include_collinear) {
          int i = (int)a.size()-1;
          while (i >= 0 && collinear(p0, a[i], a.back())) i--;
          reverse(a.begin()+i+1, a.end());
      }

      vector<pt> st;
      for (int i = 0; i < (int)a.size(); i++) {
          while (st.size() > 1 && !cw(st[st.size()-2], st.back(), a[i], include_collinear))
              st.pop_back();
          st.push_back(a[i]);
      }
      a = st;
  }
\end{lstlisting}

\subsection{SPFA}
\begin{itemize}
    \item Ricordarsi di aggiungere limite al numero di esecuzioni se possono esserci cicli negativi, altrimenti va all'infinito
\end{itemize}
\begin{lstlisting}
  const int INF = 1000000000;
  vector<vector<pair<int, int>>> adj;

  bool spfa(int s, vector<int>& d) {
      int n = adj.size();
      d.assign(n, INF);
      vector<int> cnt(n, 0);
      vector<bool> inqueue(n, false);
      queue<int> q;
      d[s] = 0;
      q.push(s);
      inqueue[s] = true;
      while (!q.empty()) {
          int v = q.front();
          q.pop();
          inqueue[v] = false;

          for (auto edge : adj[v]) {
              int to = edge.first;
              int len = edge.second;

              if (d[v] + len < d[to]) {
                  d[to] = d[v] + len;
                  if (!inqueue[to]) {
                      q.push(to);
                      inqueue[to] = true;
                      cnt[to]++;
                      if (cnt[to] > n)
                          return false;  // negative cycle
                  }
              }
          }
      }
      return true;
  }
\end{lstlisting}

\subsection{MST $n^2$}
\begin{lstlisting}
  int n;
  vector<vector<int>> adj; // adjacency matrix of graph
  const int INF = 1000000000; // weight INF means there is no edge

  struct Edge {
      int w = INF, to = -1;
  };
  void prim() {
      int total_weight = 0;
      vector<bool> selected(n, false);
      vector<Edge> min_e(n);
      min_e[0].w = 0;
      for (int i=0; i<n; ++i) {
          int v = -1;
          for (int j = 0; j < n; ++j) {
              if (!selected[j] && (v == -1 || min_e[j].w < min_e[v].w))
                  v = j;
          }

          if (min_e[v].w == INF) {
              cout << "No MST!" << endl;
              exit(0);
          }

          selected[v] = true;
          total_weight += min_e[v].w;
          if (min_e[v].to != -1)
              cout << v << " " << min_e[v].to << endl;

          for (int to = 0; to < n; ++to) {
              if (adj[v][to] < min_e[to].w)
                  min_e[to] = {adj[v][to], v};
          }
      }
      cout << total_weight << endl;
}
\end{lstlisting}

\subsection{MST $m\log n$}
\begin{lstlisting}
  vector<int> parent, rank;
  void make_set(int v) {
      parent[v] = v;
      rank[v] = 0;
  }

  int find_set(int v) {
      if (v == parent[v])
          return v;
      return parent[v] = find_set(parent[v]);
  }
  void union_sets(int a, int b) {
      a = find_set(a);
      b = find_set(b);
      if (a != b) {
          if (rank[a] < rank[b])
              swap(a, b);
          parent[b] = a;
          if (rank[a] == rank[b])
              rank[a]++;
      }
  }
  struct Edge {
      int u, v, weight;
      bool operator<(Edge const& other) {
          return weight < other.weight;
      }
  };

  int n;
  vector<Edge> edges;

  int cost = 0;
  vector<Edge> result;
  parent.resize(n);
  rank.resize(n);
  for (int i = 0; i < n; i++)
      make_set(i);

  sort(edges.begin(), edges.end());

  for (Edge e : edges) {
      if (find_set(e.u) != find_set(e.v)) {
          cost += e.weight;
          result.push_back(e);
          union_sets(e.u, e.v);
      }
  }
\end{lstlisting}

\subsection{Matexp}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

const int N = 3;

const long long M = 1000000007;

void multiply (long long A[N][N], long long B[N][N]){
    long long R[N][N];

    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++){
            R[i][j] = 0;
            for (int k = 0; k < N; k++){
                R[i][j] = (R[i][j] + A[i][k] * B[k][j]) % M;
            }
        }
    }

    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++){
            A[i][j] = R[i][j];
        }
    }
}

void power_matrix (long long A[N][N], int n){
    long long B[N][N];

    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++){
            B[i][j] = A[i][j];
        }
    }

    n = n - 1;
    while (n > 0)
    {
        if (n & 1)
            multiply (A, B);

        multiply (B,B);

        n = n >> 1;  
    }
}

long long solve_recurrence (long long A[N][N], long long B[N][1], int n){
    if (n < N)
        return B[N - 1 - n][0];
    
    power_matrix (A, n - N + 1);
    
    long long result = 0;
    
    for (int i = 0; i < N; i++)
        result = (result + A[0][i] * B[i][0]) % M;
    
    return result;
}

int main ()
{

    long long A[N][N] = {{2, 1, 3}, {1, 0, 0}, {0, 1, 0}};
    long long B[N][1] = {{3}, {2}, {1}};
    
    int n = 5;
    
    long long R_n = solve_recurrence (A, B, n);
    
    cout << "R_" << n << " = " << R_n; 

    return 0;
}
\end{lstlisting}

\subsection{Gauss}
\begin{lstlisting}
const double EPS = 1e-9;
const int INF = 2; // no need for infinity

int gauss (vector < vector<double> > a, vector<double> & ans) {
    int n = (int) a.size();
    int m = (int) a[0].size() - 1;

    vector<int> where (m, -1);
    for (int col=0, row=0; col<m && row<n; ++col) {
        int sel = row;
        for (int i=row; i<n; ++i)
            if (abs (a[i][col]) > abs (a[sel][col]))
                sel = i;
        if (abs (a[sel][col]) < EPS)
            continue;
        for (int i=col; i<=m; ++i)
            swap (a[sel][i], a[row][i]);
        where[col] = row;

        for (int i=0; i<n; ++i)
            if (i != row) {
                double c = a[i][col] / a[row][col];
                for (int j=col; j<=m; ++j)
                    a[i][j] -= a[row][j] * c;
            }
        ++row;
    }

    ans.assign (m, 0);
    for (int i=0; i<m; ++i)
        if (where[i] != -1)
            ans[i] = a[where[i]][m] / a[where[i]][i];
    for (int i=0; i<n; ++i) {
        double sum = 0;
        for (int j=0; j<m; ++j)
            sum += ans[j] * a[i][j];
        if (abs (sum - a[i][m]) > EPS)
            return 0;
    }

    for (int i=0; i<m; ++i)
        if (where[i] == -1)
            return INF;
    return 1;
}
\end{lstlisting}
